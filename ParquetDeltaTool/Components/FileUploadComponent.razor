@inject IFileProcessor FileProcessor
@inject IStorageService StorageService
@inject ISnackbar Snackbar
@inject IJSRuntime JSRuntime

<div class="@GetUploadAreaClasses()" 
     style="@GetUploadAreaStyle()"
     @ondrop="HandleDrop" 
     @ondragover="HandleDragOver" 
     @ondragenter="HandleDragEnter" 
     @ondragleave="HandleDragLeave"
     @ondragover:preventDefault="true"
     @ondrop:preventDefault="true">
    
    <MudFileUpload T="IBrowserFile" 
                   Accept="@_acceptedTypes" 
                   FilesChanged="HandleFileSelection" 
                   MaximumFileCount="10"
                   Hidden="true"
                   @ref="_fileUpload">
        <ButtonTemplate>
            <MudStack AlignItems="AlignItems.Center" Justify="Justify.Center" Style="min-height: 200px;">
                @if (_isUploading)
                {
                    <MudProgressCircular Indeterminate="true" Size="Size.Large" Color="Color.Primary" />
                    <MudText Typo="Typo.h6">Processing files...</MudText>
                    <MudText Typo="Typo.body2" Color="Color.Secondary">
                        @(_currentFile != null ? $"Processing: {_currentFile}" : "")
                    </MudText>
                }
                else
                {
                    <MudIcon Icon="Icons.Material.Filled.CloudUpload" 
                             Size="Size.Large" 
                             Color="Color.Secondary" />
                    
                    <MudText Typo="Typo.h6">
                        Drop files here or click to upload
                    </MudText>
                    
                    <MudText Typo="Typo.body2" Color="Color.Secondary">
                        Supported formats: Parquet, CSV, JSON
                    </MudText>
                    
                    <MudButton Variant="Variant.Filled" 
                              Color="Color.Primary" 
                              StartIcon="Icons.Material.Filled.Upload"
                              Size="Size.Large"
                              Class="mt-4">
                        Choose Files
                    </MudButton>
                }
            </MudStack>
        </ButtonTemplate>
    </MudFileUpload>
    
    @if (_selectedFiles.Any())
    {
        <MudDivider Class="my-4" />
        <MudText Typo="Typo.h6" GutterBottom="true">Selected Files</MudText>
        
        <MudList Dense="true">
            @foreach (var file in _selectedFiles)
            {
                <MudListItem>
                    <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
                        <MudStack Row="true" AlignItems="AlignItems.Center">
                            <MudIcon Icon="@GetFileIcon(DetectFileFormat(file.Name))" />
                            <div>
                                <MudText Typo="Typo.body1">@file.Name</MudText>
                                <MudText Typo="Typo.body2" Color="Color.Secondary">
                                    @FormatFileSize(file.Size) • @DetectFileFormat(file.Name)
                                </MudText>
                            </div>
                        </MudStack>
                        
                        <MudIconButton Icon="Icons.Material.Filled.Close" 
                                      Size="Size.Small" 
                                      OnClick="@(() => RemoveFile(file))" />
                    </MudStack>
                </MudListItem>
            }
        </MudList>
        
        <MudButton Variant="Variant.Filled" 
                  Color="Color.Primary" 
                  StartIcon="Icons.Material.Filled.Upload"
                  OnClick="ProcessFiles"
                  Disabled="@_isUploading"
                  Class="mt-4">
            Process @_selectedFiles.Count File@(_selectedFiles.Count == 1 ? "" : "s")
        </MudButton>
    }
</div>

@code {
    [Parameter] public EventCallback<FileMetadata> OnFileUploaded { get; set; }

    private bool _isUploading = false;
    private bool _isDragOver = false;
    private string? _currentFile = null;
    private int _currentFileIndex = 0;
    private int _totalFiles = 0;
    private double _currentProgress = 0;
    private List<IBrowserFile> _selectedFiles = new();
    private List<string> _validationErrors = new();
    
    private readonly string _acceptedTypes = ".parquet,.csv,.json,.jsonl,.ndjson,.avro,.orc";
    private readonly long _maxFileSize = 2L * 1024 * 1024 * 1024; // 2GB
    private readonly HashSet<string> _supportedExtensions = new() { ".parquet", ".csv", ".json", ".jsonl", ".ndjson", ".avro", ".orc" };
    
    private MudFileUpload<IBrowserFile> _fileUpload = null!;

    private async Task HandleFileSelection(IBrowserFile file)
    {
        await AddFileWithValidation(file);
    }

    private async Task AddFileWithValidation(IBrowserFile file)
    {
        _validationErrors.Clear();

        // Validate file
        var isValid = ValidateFile(file);
        if (!isValid)
        {
            StateHasChanged();
            return;
        }

        // Check for duplicates
        if (_selectedFiles.Any(f => f.Name == file.Name && f.Size == file.Size))
        {
            Snackbar.Add($"File '{file.Name}' is already selected", Severity.Warning);
            return;
        }

        _selectedFiles.Add(file);
        Snackbar.Add($"Added {file.Name} to upload queue", Severity.Info);
        StateHasChanged();
    }

    private bool ValidateFile(IBrowserFile file)
    {
        var isValid = true;

        // Check file size
        if (file.Size > _maxFileSize)
        {
            _validationErrors.Add($"{file.Name}: File size ({FormatFileSize(file.Size)}) exceeds maximum allowed size (2GB)");
            isValid = false;
        }

        if (file.Size == 0)
        {
            _validationErrors.Add($"{file.Name}: File is empty");
            isValid = false;
        }

        // Check file extension
        var extension = Path.GetExtension(file.Name).ToLowerInvariant();
        if (string.IsNullOrEmpty(extension) || !_supportedExtensions.Contains(extension))
        {
            _validationErrors.Add($"{file.Name}: Unsupported file format. Supported formats: {string.Join(", ", _supportedExtensions)}");
            isValid = false;
        }

        // Show validation errors
        if (!isValid)
        {
            foreach (var error in _validationErrors)
            {
                Snackbar.Add(error, Severity.Error);
            }
        }

        return isValid;
    }

    private void RemoveFile(IBrowserFile file)
    {
        _selectedFiles.Remove(file);
        Snackbar.Add($"Removed {file.Name} from upload queue", Severity.Info);
        StateHasChanged();
    }

    private async Task ProcessFiles()
    {
        if (!_selectedFiles.Any() || _isUploading)
            return;

        _isUploading = true;
        _totalFiles = _selectedFiles.Count;
        _currentFileIndex = 0;
        _currentProgress = 0;
        StateHasChanged();

        var successCount = 0;
        var failedFiles = new List<string>();

        try
        {
            for (var i = 0; i < _selectedFiles.Count; i++)
            {
                var file = _selectedFiles[i];
                _currentFile = file.Name;
                _currentFileIndex = i + 1;
                _currentProgress = 0;
                StateHasChanged();

                try
                {
                    // Read file content
                    using var stream = file.OpenReadStream(maxAllowedSize: _maxFileSize);
                    using var memoryStream = new MemoryStream();
                    
                    // Copy with progress tracking
                    var buffer = new byte[81920]; // 80KB buffer
                    int bytesRead;
                    long totalBytesRead = 0;
                    
                    while ((bytesRead = await stream.ReadAsync(buffer)) > 0)
                    {
                        await memoryStream.WriteAsync(buffer, 0, bytesRead);
                        totalBytesRead += bytesRead;
                        _currentProgress = (double)totalBytesRead / file.Size * 100;
                        StateHasChanged();
                    }

                    var fileBytes = memoryStream.ToArray();

                    // Store in IndexedDB
                    var fileId = Guid.NewGuid();
                    var format = DetectFileFormat(file.Name);
                    
                    // Create metadata
                    var metadata = new FileMetadata
                    {
                        FileId = fileId,
                        FileName = file.Name,
                        FileSize = file.Size,
                        Format = format,
                        ModifiedAt = DateTime.Now,
                        RowCount = 0, // Will be updated during processing
                        CreatedAt = DateTime.Now
                    };

                    // Store file using JavaScript storage service
                    await JSRuntime.InvokeVoidAsync("storeFile", fileId.ToString(), file.Name, fileBytes, metadata);

                    // Process file metadata and schema
                    try
                    {
                        var processedMetadata = await FileProcessor.LoadFileAsync(new MemoryStream(fileBytes), format);
                        processedMetadata.FileId = fileId;
                        processedMetadata.FileName = file.Name;
                        processedMetadata.FileSize = file.Size;
                        
                        // Update stored metadata with processed information
                        await JSRuntime.InvokeVoidAsync("storeFile", fileId.ToString(), file.Name, fileBytes, processedMetadata);
                        
                        // Notify parent component
                        await OnFileUploaded.InvokeAsync(processedMetadata);
                        
                        successCount++;
                        Snackbar.Add($"✅ Successfully processed {file.Name}", Severity.Success);
                    }
                    catch (Exception processingEx)
                    {
                        // File was stored but processing failed
                        await OnFileUploaded.InvokeAsync(metadata);
                        Snackbar.Add($"⚠️ {file.Name} uploaded but processing failed: {processingEx.Message}", Severity.Warning);
                        successCount++;
                    }
                }
                catch (Exception ex)
                {
                    failedFiles.Add($"{file.Name}: {ex.Message}");
                    Snackbar.Add($"❌ Failed to process {file.Name}: {ex.Message}", Severity.Error);
                }
            }
            
            // Show summary
            if (successCount > 0)
            {
                Snackbar.Add($"Successfully processed {successCount} of {_totalFiles} files", Severity.Success);
            }
            
            if (failedFiles.Any())
            {
                Snackbar.Add($"Failed to process {failedFiles.Count} files", Severity.Error);
            }
            
            // Clear selected files after processing
            _selectedFiles.Clear();
        }
        finally
        {
            _isUploading = false;
            _currentFile = null;
            _currentFileIndex = 0;
            _totalFiles = 0;
            _currentProgress = 0;
            StateHasChanged();
        }
    }

    private FileFormat DetectFileFormat(string fileName)
    {
        var extension = Path.GetExtension(fileName).ToLowerInvariant();
        return extension switch
        {
            ".parquet" => FileFormat.Parquet,
            ".csv" => FileFormat.CSV,
            ".json" or ".jsonl" => FileFormat.JSON,
            _ => FileFormat.Parquet // Default
        };
    }

    private string GetFileIcon(FileFormat format)
    {
        return format switch
        {
            FileFormat.Parquet => Icons.Material.Filled.TableChart,
            FileFormat.Delta => Icons.Material.Filled.ChangeHistory,
            FileFormat.CSV => Icons.Material.Filled.GridOn,
            FileFormat.JSON => Icons.Material.Filled.DataObject,
            _ => Icons.Material.Filled.InsertDriveFile
        };
    }

    private string FormatFileSize(long bytes)
    {
        string[] suffixes = { "B", "KB", "MB", "GB", "TB" };
        int counter = 0;
        double number = bytes;
        
        while (Math.Round(number / 1024) >= 1)
        {
            number = number / 1024;
            counter++;
        }
        
        return $"{number:n1} {suffixes[counter]}";
    }

    // Drag and drop event handlers
    private Task HandleDrop(DragEventArgs e)
    {
        _isDragOver = false;
        StateHasChanged();
        
        if (_isUploading) return Task.CompletedTask;

        // For now, just show a message that drag and drop is not fully implemented
        // Real implementation would require custom JavaScript interop to handle file drops
        Snackbar.Add("Drag and drop detected! Please use the 'Choose Files' button for now.", Severity.Info);
        return Task.CompletedTask;
    }

    private void HandleDragOver(DragEventArgs e)
    {
        e.DataTransfer.DropEffect = "copy";
    }

    private void HandleDragEnter(DragEventArgs e)
    {
        _isDragOver = true;
        StateHasChanged();
    }

    private void HandleDragLeave(DragEventArgs e)
    {
        _isDragOver = false;
        StateHasChanged();
    }

    // Styling methods for drag and drop area
    private string GetUploadAreaClasses()
    {
        var classes = "pa-6 ma-2 rounded-lg border-2 border-dashed text-center cursor-pointer transition-all";

        if (_isDragOver)
        {
            classes += " mud-elevation-4";
        }
        else
        {
            classes += " hover:mud-elevation-2";
        }

        return classes;
    }

    private string GetUploadAreaStyle()
    {
        if (_isDragOver)
        {
            return "background-color: var(--mud-palette-primary-lighten); border-color: var(--mud-palette-primary);";
        }
        
        return "border-color: var(--mud-palette-lines-default); background-color: var(--mud-palette-surface);";
    }
}